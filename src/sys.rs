/* automatically generated by rust-bindgen 0.70.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\defgroup opaque_handles C API: Opaque handles\n \\{\n/\n/*! \\brief Handle to a decision tree ensemble model"]
pub type TreeliteModelHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to a model builder object"]
pub type TreeliteModelBuilderHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to a configuration of GTIL predictor"]
pub type TreeliteGTILConfigHandle = *mut ::std::os::raw::c_void;
#[doc = " \\defgroup buffer_protocol C API: Python buffer protocol (PEP 3118)\n \\{\n/\n/*! \\brief Represent a frame in the Python buffer protocol (PEP 3118).\n\n We use a simplified representation to hold only 1-D arrays with stride 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TreelitePyBufferFrame {
    pub buf: *mut ::std::os::raw::c_void,
    pub format: *mut ::std::os::raw::c_char,
    pub itemsize: usize,
    pub nitem: usize,
}
const _: () = {
    ["Size of TreelitePyBufferFrame"][::std::mem::size_of::<TreelitePyBufferFrame>() - 32usize];
    ["Alignment of TreelitePyBufferFrame"]
        [::std::mem::align_of::<TreelitePyBufferFrame>() - 8usize];
    ["Offset of field: TreelitePyBufferFrame::buf"]
        [::std::mem::offset_of!(TreelitePyBufferFrame, buf) - 0usize];
    ["Offset of field: TreelitePyBufferFrame::format"]
        [::std::mem::offset_of!(TreelitePyBufferFrame, format) - 8usize];
    ["Offset of field: TreelitePyBufferFrame::itemsize"]
        [::std::mem::offset_of!(TreelitePyBufferFrame, itemsize) - 16usize];
    ["Offset of field: TreelitePyBufferFrame::nitem"]
        [::std::mem::offset_of!(TreelitePyBufferFrame, nitem) - 24usize];
};
extern "C" {
    #[doc = " \\defgroup model_loader C API: Model loaders for XGBoost and LightGBM\n \\{\n/\n/*!\n \\brief Load a model file generated by XGBoost (dmlc/xgboost), stored in the legacy binary\n        format.\n \\param filename Name of model file\n \\param config_json JSON string consisting key-value pairs; used for configuring the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadXGBoostModelLegacyBinary(
        filename: *const ::std::os::raw::c_char,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load an XGBoost model from a memory buffer using the legacy binary format.\n \\param buf Memory buffer\n \\param len Size of memory buffer\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadXGBoostModelLegacyBinaryFromMemoryBuffer(
        buf: *const ::std::os::raw::c_void,
        len: usize,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deprecated. Please use \\ref TreeliteLoadXGBoostModelJSON instead."]
    pub fn TreeliteLoadXGBoostModel(
        filename: *const ::std::os::raw::c_char,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deprecated. Please use \\ref TreeliteLoadXGBoostModelFromJSONString instead."]
    pub fn TreeliteLoadXGBoostModelFromString(
        json_str: *const ::std::os::raw::c_char,
        length: usize,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a model file generated by XGBoost (dmlc/xgboost), stored in the JSON format.\n \\param filename Name of model file\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadXGBoostModelJSON(
        filename: *const ::std::os::raw::c_char,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load an XGBoost model from a JSON string\n \\param json_str JSON string containing the XGBoost model\n \\param length Length of the JSON string\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadXGBoostModelFromJSONString(
        json_str: *const ::std::os::raw::c_char,
        length: usize,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a model file generated by XGBoost (dmlc/xgboost), stored in the UBJSON format.\n \\param filename Name of model file\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadXGBoostModelUBJSON(
        filename: *const ::std::os::raw::c_char,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load an XGBoost model from a UBJSON string\n \\param ubjson_str UBJSON byte sequence\n \\param length Length of the byte sequence\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadXGBoostModelFromUBJSONString(
        ubjson_str: *const u8,
        length: usize,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Inspect the first few bytes of an XGBoost model and heuristically determine whether\n        it's using the JSON or UBJSON format.\n \\param filename Name of model file\n \\param out_str String indicating the model type (\"json\", \"ubjson\", or \"unknown\")\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteDetectXGBoostFormat(
        filename: *const ::std::os::raw::c_char,
        out_str: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a model file generated by LightGBM (Microsoft/LightGBM). The\n        model file must contain a decision tree ensemble.\n \\param filename Name of model file\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadLightGBMModel(
        filename: *const ::std::os::raw::c_char,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a LightGBM model from a string. The string should be created with the\n        model_to_string() method in LightGBM.\n \\param model_str Model string\n \\param config_json Null-terminated JSON string consisting key-value pairs; used for configuring\n                    the model parser\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadLightGBMModelFromString(
        model_str: *const ::std::os::raw::c_char,
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup sklearn C API: Model loaders for scikit-learn\n \\{\n/\n/*!\n \\brief Load a scikit-learn RandomForestRegressor model from a collection of arrays. Refer to\n        https://scikit-learn.org/stable/auto_examples/tree/plot_unveil_tree_structure.html to\n        learn the meaning of the arrays in detail. Note that this function can also be used to\n        load an ensemble of extremely randomized trees (sklearn.ensemble.ExtraTreesRegressor).\n \\param n_estimators Number of trees in the random forest\n \\param n_features Number of features in the training data\n \\param n_targets Number of targets (outputs)\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param children_left children_left[i][k] stores the ID of the left child node of node k of the\n                      i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param children_right children_right[i][k] stores the ID of the right child node of node k of the\n                       i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param feature feature[i][k] stores the ID of the feature used in the binary tree split at node k\n                of the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param threshold threshold[i][k] stores the threshold used in the binary tree split at node k of\n                  the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param value value[i][k] stores the leaf output of node k of the i-th tree. This is only defined\n              if node k is a leaf node.\n \\param n_node_samples n_node_samples[i][k] stores the number of data samples associated with\n                       node k of the i-th tree.\n \\param weighted_n_node_samples weighted_n_node_samples[i][k] stores the sum of weighted data\n                                samples associated with node k of the i-th tree.\n \\param impurity impurity[i][k] stores the impurity measure (gini, entropy etc) associated with\n                 node k of the i-th tree.\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnRandomForestRegressor(
        n_estimators: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        n_targets: ::std::os::raw::c_int,
        node_count: *const i64,
        children_left: *mut *const i64,
        children_right: *mut *const i64,
        feature: *mut *const i64,
        threshold: *mut *const f64,
        value: *mut *const f64,
        n_node_samples: *mut *const i64,
        weighted_n_node_samples: *mut *const f64,
        impurity: *mut *const f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a scikit-learn IsolationForest model from a collection of arrays. Refer to\n        https://scikit-learn.org/stable/auto_examples/tree/plot_unveil_tree_structure.html to\n        learn the meaning of the arrays in detail.\n \\param n_estimators Number of trees in the isolation forest\n \\param n_features Number of features in the training data\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param children_left children_left[i][k] stores the ID of the left child node of node k of the\n                      i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param children_right children_right[i][k] stores the ID of the right child node of node k of the\n                       i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param feature feature[i][k] stores the ID of the feature used in the binary tree split at node k\n                of the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param threshold threshold[i][k] stores the threshold used in the binary tree split at node k of\n                  the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param value value[i][k] stores the expected isolation depth of node k of the i-th tree. This is\n              only defined if node k is a leaf node.\n \\param n_node_samples n_node_samples[i][k] stores the number of data samples associated with\n                       node k of the i-th tree.\n \\param weighted_n_node_samples weighted_n_node_samples[i][k] stores the sum of weighted data\n                                samples associated with node k of the i-th tree.\n \\param impurity Not used, but must be passed as array of arrays for each tree and node.\n \\param ratio_c Standardizing constant to use for calculation of the anomaly score.\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnIsolationForest(
        n_estimators: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        node_count: *const i64,
        children_left: *mut *const i64,
        children_right: *mut *const i64,
        feature: *mut *const i64,
        threshold: *mut *const f64,
        value: *mut *const f64,
        n_node_samples: *mut *const i64,
        weighted_n_node_samples: *mut *const f64,
        impurity: *mut *const f64,
        ratio_c: f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a scikit-learn RandomForestClassifier model from a collection of arrays. Refer to\n        https://scikit-learn.org/stable/auto_examples/tree/plot_unveil_tree_structure.html to\n        learn the meaning of the arrays in detail. Note that this function can also be used to\n        load an ensemble of extremely randomized trees (sklearn.ensemble.ExtraTreesClassifier).\n \\param n_estimators Number of trees in the random forest\n \\param n_features Number of features in the training data\n \\param n_targets Number of targets (outputs)\n \\param n_classes n_classes[i] stores the number of classes in the i-th target\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param children_left children_left[i][k] stores the ID of the left child node of node k of the\n                      i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param children_right children_right[i][k] stores the ID of the right child node of node k of the\n                       i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param feature feature[i][k] stores the ID of the feature used in the binary tree split at node k\n                of the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param threshold threshold[i][k] stores the threshold used in the binary tree split at node k of\n                  the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param value value[i][k] stores the leaf output of node k of the i-th tree. This is only defined\n              if node k is a leaf node.\n \\param n_node_samples n_node_samples[i][k] stores the number of data samples associated with\n                       node k of the i-th tree.\n \\param weighted_n_node_samples weighted_n_node_samples[i][k] stores the sum of weighted data\n                                samples associated with node k of the i-th tree.\n \\param impurity impurity[i][k] stores the impurity measure (gini, entropy etc) associated with\n                 node k of the i-th tree.\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnRandomForestClassifier(
        n_estimators: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        n_targets: ::std::os::raw::c_int,
        n_classes: *const i32,
        node_count: *const i64,
        children_left: *mut *const i64,
        children_right: *mut *const i64,
        feature: *mut *const i64,
        threshold: *mut *const f64,
        value: *mut *const f64,
        n_node_samples: *mut *const i64,
        weighted_n_node_samples: *mut *const f64,
        impurity: *mut *const f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a scikit-learn GradientBoostingRegressor model from a collection of arrays. Refer\n        to https://scikit-learn.org/stable/auto_examples/tree/plot_unveil_tree_structure.html to\n        learn the meaning of the arrays in detail.\n        Note: GradientBoostingRegressor does not support multiple targets (outputs).\n \\param n_iter Number of boosting iterations\n \\param n_features Number of features in the training data\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param children_left children_left[i][k] stores the ID of the left child node of node k of the\n                      i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param children_right children_right[i][k] stores the ID of the right child node of node k of the\n                       i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param feature feature[i][k] stores the ID of the feature used in the binary tree split at node k\n                of the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param threshold threshold[i][k] stores the threshold used in the binary tree split at node k of\n                  the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param value value[i][k] stores the leaf output of node k of the i-th tree. This is only defined\n              if node k is a leaf node.\n \\param n_node_samples n_node_samples[i][k] stores the number of data samples associated with\n                       node k of the i-th tree.\n \\param weighted_n_node_samples weighted_n_node_samples[i][k] stores the sum of weighted data\n                                samples associated with node k of the i-th tree.\n \\param impurity impurity[i][k] stores the impurity measure (gini, entropy etc) associated with\n                 node k of the i-th tree.\n \\param base_scores Baseline predictions for outputs. At prediction, margin scores will be\n                    adjusted by this amount before applying the post-processing (link)\n                    function. Required shape: (1,)\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnGradientBoostingRegressor(
        n_iter: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        node_count: *const i64,
        children_left: *mut *const i64,
        children_right: *mut *const i64,
        feature: *mut *const i64,
        threshold: *mut *const f64,
        value: *mut *const f64,
        n_node_samples: *mut *const i64,
        weighted_n_node_samples: *mut *const f64,
        impurity: *mut *const f64,
        base_scores: *const f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a scikit-learn GradientBoostingClassifier model from a collection of arrays. Refer\n        to https://scikit-learn.org/stable/auto_examples/tree/plot_unveil_tree_structure.html to\n        learn the meaning of the arrays in detail.\n        Note: GradientBoostingClassifier does not support multiple targets (outputs).\n \\param n_iter Number of boosting iterations\n \\param n_features Number of features in the training data\n \\param n_classes Number of classes in the target variable\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param children_left children_left[i][k] stores the ID of the left child node of node k of the\n                      i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param children_right children_right[i][k] stores the ID of the right child node of node k of the\n                       i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param feature feature[i][k] stores the ID of the feature used in the binary tree split at node k\n                of the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param threshold threshold[i][k] stores the threshold used in the binary tree split at node k of\n                  the i-th tree. This is only defined if node k is an internal (non-leaf) node.\n \\param value value[i][k] stores the leaf output of node k of the i-th tree. This is only defined\n              if node k is a leaf node.\n \\param n_node_samples n_node_samples[i][k] stores the number of data samples associated with\n                       node k of the i-th tree.\n \\param weighted_n_node_samples weighted_n_node_samples[i][k] stores the sum of weighted data\n                                samples associated with node k of the i-th tree.\n \\param impurity impurity[i][k] stores the impurity measure (gini, entropy etc) associated with\n                 node k of the i-th tree.\n \\param base_scores Baseline predictions for outputs. At prediction, margin scores will be\n                    adjusted by this amount before applying the post-processing (link)\n                    function. Required shape: (n_classes,)\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnGradientBoostingClassifier(
        n_iter: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        n_classes: ::std::os::raw::c_int,
        node_count: *const i64,
        children_left: *mut *const i64,
        children_right: *mut *const i64,
        feature: *mut *const i64,
        threshold: *mut *const f64,
        value: *mut *const f64,
        n_node_samples: *mut *const i64,
        weighted_n_node_samples: *mut *const f64,
        impurity: *mut *const f64,
        base_scores: *const f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a scikit-learn HistGradientBoostingRegressor model from a collection of arrays.\n        Note: HistGradientBoostingRegressor does not support multiple targets (outputs).\n \\param n_iter Number of boosting iterations\n \\param n_features Number of features in the training data\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param nodes nodes[i][k] stores the k-th node of the i-th tree.\n \\param expected_sizeof_node_struct Expected size of Node struct, in bytes\n \\param n_categorical_splits n_categorical_splits[i] stores the number of categorical splits\n                             in the i-th tree.\n \\param raw_left_cat_bitsets raw_left_cat_bitsets[i][k] stores the bitmaps for node k of tree i.\n                             The bitmaps are used to represent categorical tests.\n                             Shape of raw_left_cat_bitsets[i]: (n_categorical_splits, 8)\n \\param known_cat_bitsets Bitsets representing the list of known categories per categorical\n                          feature. Shape: (n_categorical_features, 8)\n \\param known_cat_bitsets_offset_map Map from an original feature index to the corresponding\n                                     index in the known_cat_bitsets array. Shape: (n_features,)\n \\param features_map Mapping to re-order features. This is needed because HistGradientBoosting\n                     estimator internally re-orders features using ColumnTransformer so that\n                     the categorical features come before the numerical features.\n \\param categories_map Mapping to transform categorical features. This is needed because\n                       HistGradientBoosting estimator embeds an OrdinalEncoder.\n                       categories_map[i] represents the mapping for i-th categorical feature.\n \\param base_scores Baseline predictions for outputs. At prediction, margin scores will be\n                    adjusted by this amount before applying the post-processing (link)\n                    function. Required shape: (1,)\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnHistGradientBoostingRegressor(
        n_iter: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        node_count: *const i64,
        nodes: *mut *const ::std::os::raw::c_void,
        expected_sizeof_node_struct: ::std::os::raw::c_int,
        n_categorical_splits: u32,
        raw_left_cat_bitsets: *mut *const u32,
        known_cat_bitsets: *const u32,
        known_cat_bitsets_offset_map: *const u32,
        features_map: *const i32,
        categories_map: *mut *const i64,
        base_scores: *const f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a scikit-learn HistGradientBoostingClassifier model from a collection of arrays.\n        Note: HistGradientBoostingClassifier does not support multiple targets (outputs).\n \\param n_iter Number of boosting iterations\n \\param n_features Number of features in the training data\n \\param n_classes Number of classes in the target variable\n \\param node_count node_count[i] stores the number of nodes in the i-th tree\n \\param nodes nodes[i][k] stores the k-th node of the i-th tree.\n \\param expected_sizeof_node_struct Expected size of Node struct, in bytes\n \\param n_categorical_splits n_categorical_splits[i] stores the number of categorical splits\n                             in the i-th tree.\n \\param raw_left_cat_bitsets raw_left_cat_bitsets[i][k] stores the bitmaps for node k of tree i.\n                             The bitmaps are used to represent categorical tests.\n                             Shape of raw_left_cat_bitsets[i]: (n_categorical_splits, 8)\n\n \\param known_cat_bitsets Bitsets representing the list of known categories per categorical\n                          feature. Shape: (n_categorical_features, 8)\n \\param known_cat_bitsets_offset_map Map from an original feature index to the corresponding\n                                     index in the known_cat_bitsets array. Shape: (n_features,)\n \\param features_map Mapping to re-order features. This is needed because HistGradientBoosting\n                     estimator internally re-orders features using ColumnTransformer so that\n                     the categorical features come before the numerical features.\n \\param categories_map Mapping to transform categorical features. This is needed because\n                       HistGradientBoosting estimator embeds an OrdinalEncoder.\n                       categories_map[i] represents the mapping for i-th categorical feature.\n \\param base_scores Baseline predictions for outputs. At prediction, margin scores will be\n                    adjusted by this amount before applying the post-processing (link)\n                    function. Required shape: (1,) for binary classification;\n                    (n_classes,) for multi-class classification\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteLoadSKLearnHistGradientBoostingClassifier(
        n_iter: ::std::os::raw::c_int,
        n_features: ::std::os::raw::c_int,
        n_classes: ::std::os::raw::c_int,
        node_count: *const i64,
        nodes: *mut *const ::std::os::raw::c_void,
        expected_sizeof_node_struct: ::std::os::raw::c_int,
        n_categorical_splits: u32,
        raw_left_cat_bitsets: *mut *const u32,
        known_cat_bitsets: *const u32,
        known_cat_bitsets_offset_map: *const u32,
        features_map: *const i32,
        categories_map: *mut *const i64,
        base_scores: *const f64,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup model_builder C API: Functions to build model objects\n \\{\n/\n/*!\n \\brief Initialize a model builder object from a JSON string.\n\n The JSON string must contain all relevant metadata, including:\n - threshold_type: Type of thresholds in the tree model\n - leaf_output_type: Type of leaf outputs in the tree model\n - metadata: Model metadata, consisting of following subfields:\n   * num_feature: Number of features\n   * task_type: Task type\n   * average_tree_output: Whether to average outputs of trees\n   * num_target: Number of targets\n   * num_class: Number of classes. num_class[i] is the number of classes of target i.\n   * leaf_vector_shape: Shape of the output from each leaf node\n - tree_annotation: Annotation for individual trees, consisting of following subfields:\n   * num_tree: Number of trees\n   * target_id: target_id Target that each tree is associated with\n   * class_id: Class that each tree is associated with\n - postprocessor: Postprocessor for prediction outputs, consisting of following subfields:\n   * name: Name of postprocessor\n   * config_json: Optional JSON string to configure the postprocessor\n - base_scores: Baseline scores for targets and classes, before adding tree outputs.\n                Also known as the intercept.\n - attributes: Arbitrary JSON object, to be stored in the \"attributes\" field in the\n               model object.\n\n \\param json_str JSON string containing relevant metadata.\n \\param out Model builder object\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteGetModelBuilder(
        json_str: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelBuilderHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Delete model builder object from memory\n \\param model_builder Model builder object to be deleted\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteDeleteModelBuilder(
        model_builder: TreeliteModelBuilderHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start a new tree\n \\param model_builder Model builder object\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderStartTree(
        model_builder: TreeliteModelBuilderHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief End the current tree\n \\param model_builder Model builder object\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderEndTree(
        model_builder: TreeliteModelBuilderHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start a new node\n \\param model_builder Model builder object\n \\param node_key Integer key that unique identifies the node.\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderStartNode(
        model_builder: TreeliteModelBuilderHandle,
        node_key: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief End the current node\n \\param model_builder Model builder object\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderEndNode(
        model_builder: TreeliteModelBuilderHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Declare the current node as a numerical test node, where the test is of form\n        [feature value] [cmp] [threshold]. Data points for which the test evaluates to True\n        will be mapped to the left child node; all other data points (for which the test\n        evaluates to False) will be mapped to the right child node.\n \\param model_builder Model builder object\n \\param split_index Feature ID\n \\param threshold Threshold\n \\param default_left Whether the missing value should be mapped to the left child\n \\param cmp Comparison operator\n \\param left_child_key Integer key that unique identifies the left child node.\n \\param right_child_key  Integer key that unique identifies the right child node.\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderNumericalTest(
        model_builder: TreeliteModelBuilderHandle,
        split_index: i32,
        threshold: f64,
        default_left: ::std::os::raw::c_int,
        cmp: *const ::std::os::raw::c_char,
        left_child_key: ::std::os::raw::c_int,
        right_child_key: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Declare the current node as a categorical test node, where the test is of form\n        [feature value] \\\\in [category list].\n \\param model_builder Model builder object\n \\param split_index Feature ID\n \\param default_left Whether the missing value should be mapped to the left child\n \\param category_list List of categories to be tested for match\n \\param category_list_len Length of category_list\n \\param category_list_right_child Whether the data points for which the test evaluates to True\n                                  should be mapped to the right child or the left child.\n \\param left_child_key Integer key that unique identifies the left child node.\n \\param right_child_key Integer key that unique identifies the right child node.\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderCategoricalTest(
        model_builder: TreeliteModelBuilderHandle,
        split_index: i32,
        default_left: ::std::os::raw::c_int,
        category_list: *const u32,
        category_list_len: usize,
        category_list_right_child: ::std::os::raw::c_int,
        left_child_key: ::std::os::raw::c_int,
        right_child_key: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Declare the current node as a leaf node with a scalar output\n \\param model_builder Model builder object\n \\param leaf_value Value of leaf output\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderLeafScalar(
        model_builder: TreeliteModelBuilderHandle,
        leaf_value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Declare the current node as a leaf node with a vector output (float32)\n \\param model_builder Model builder object\n \\param leaf_vector Value of leaf output\n \\param leaf_vector_len Length of leaf_vector\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderLeafVectorFloat32(
        model_builder: TreeliteModelBuilderHandle,
        leaf_vector: *const f32,
        leaf_vector_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Declare the current node as a leaf node with a vector output (float64)\n \\param model_builder Model builder object\n \\param leaf_vector Value of leaf output\n \\param leaf_vector_len Length of leaf_vector\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderLeafVectorFloat64(
        model_builder: TreeliteModelBuilderHandle,
        leaf_vector: *const f64,
        leaf_vector_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Specify the gain (loss reduction) that's resulted from the current split.\n \\param model_builder Model builder object\n \\param gain Gain (loss reduction)\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderGain(
        model_builder: TreeliteModelBuilderHandle,
        gain: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Specify the number of data points (samples) that are mapped to the current node.\n \\param model_builder Model builder object\n \\param data_count Number of data points\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderDataCount(
        model_builder: TreeliteModelBuilderHandle,
        data_count: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Specify the weighted sample count or the sum of Hessians for the data points that\n        are mapped to the current node.\n \\param model_builder Model builder object\n \\param sum_hess Weighted sample count or the sum of Hessians\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteModelBuilderSumHess(
        model_builder: TreeliteModelBuilderHandle,
        sum_hess: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Conclude model building and obtain the final model object.\n \\param model_builder Model builder object\n \\param out Final model object"]
    pub fn TreeliteModelBuilderCommitModel(
        model_builder: TreeliteModelBuilderHandle,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup model_manager C API: Functions to query and modify model objects\n \\{\n/\n/*!\n \\brief Dump a model object as a JSON string\n \\param handle The handle to the model object\n \\param pretty_print Whether to pretty-print JSON string (0 for false, != 0 for true)\n \\param out_json_str The JSON string\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteDumpAsJSON(
        handle: TreeliteModelHandle,
        pretty_print: ::std::os::raw::c_int,
        out_json_str: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the input type of a Treelite model object\n \\param model Treelite Model object\n \\param out_str String representation of input type\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGetInputType(
        model: TreeliteModelHandle,
        out_str: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the output type of a Treelite model object\n \\param model Treelite Model object\n \\param out_str String representation of output type\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGetOutputType(
        model: TreeliteModelHandle,
        out_str: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the number of trees in the model\n \\param model Model to query\n \\param out Number of trees\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteQueryNumTree(
        model: TreeliteModelHandle,
        out: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the number of features used in the model\n \\param model Model to query\n \\param out Number of features\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteQueryNumFeature(
        model: TreeliteModelHandle,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Concatenate multiple model objects into a single model object by copying\n        all member trees into the destination model object\n \\param objs Pointer to the beginning of the list of model objects\n \\param len Number of model objects\n \\param out Used to save the concatenated model"]
    pub fn TreeliteConcatenateModelObjects(
        objs: *const TreeliteModelHandle,
        len: usize,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Delete model from memory\n \\param handle Model to remove\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteFreeModel(handle: TreeliteModelHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup serializer C API: Functions to serialize model objects\n \\{\n/\n/*!\n \\brief Serialize (persist) a model object to disk\n \\param handle Handle to the model object\n \\param filename Name of the file to which to serialize the model. The file will be using a\n                 binary format that's optimized to store the Treelite model object efficiently.\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteSerializeModelToFile(
        handle: TreeliteModelHandle,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deserialize (load) a model object from disk\n \\param filename Name of the file from which to deserialize the model. The file should be created\n                 by a call to \\ref TreeliteSerializeModelToFile.\n \\param out Handle to the model object\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteDeserializeModelFromFile(
        filename: *const ::std::os::raw::c_char,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Serialize (persist) a model object to a byte sequence\n \\param handle Handle to the model object\n \\param out_bytes Byte sequence containing serialized model\n \\param out_bytes_len Length of out_bytes\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteSerializeModelToBytes(
        handle: TreeliteModelHandle,
        out_bytes: *mut *const ::std::os::raw::c_char,
        out_bytes_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deserialize (load) a model object from a byte sequence\n \\param bytes Byte sequence containing serialized model. The string should be created by a call to\n              \\ref TreeliteSerializeModelToBytes.\n \\param bytes_len Length of bytes\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteDeserializeModelFromBytes(
        bytes: *const ::std::os::raw::c_char,
        bytes_len: usize,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Serialize a model object using the Python buffer protocol (PEP 3118).\n \\param handle Handle to the model object\n \\param out_frames Pointer to buffer frames\n \\param out_num_frames Number of buffer frames\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteSerializeModelToPyBuffer(
        handle: TreeliteModelHandle,
        out_frames: *mut *mut TreelitePyBufferFrame,
        out_num_frames: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deserialize a model object using the Python buffer protocol (PEP 3118).\n \\param frames Buffer frames\n \\param num_frames Number of buffer frames\n \\param out Loaded model\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteDeserializeModelFromPyBuffer(
        frames: *mut TreelitePyBufferFrame,
        num_frames: usize,
        out: *mut TreeliteModelHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a configuration for GTIL predictor from a JSON string.\n \\param config_json a JSON string with the following fields:\n   - \"nthread\" (optional): Number of threads used for initializing DMatrix.\n                           Set <= 0 to use all CPU cores.\n   - \"predict_type\" (required): Must be one of the following.\n     - \"default\": Sum over trees and apply post-processing\n     - \"raw\": Sum over trees, but don't apply post-processing; get raw margin scores instead.\n     - \"leaf_id\": Output one (integer) leaf ID per tree.\n     - \"score_per_tree\": Output one or more margin scores per tree.\n \\param out Parsed configuration\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGTILParseConfig(
        config_json: *const ::std::os::raw::c_char,
        out: *mut TreeliteGTILConfigHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Delete a GTIL configuration from memory\n \\param handle Handle to the GTIL configuration to be deleted\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGTILDeleteConfig(handle: TreeliteGTILConfigHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Given a data matrix, query the necessary shape of array to hold predictions for all\n        data points.\n \\param model Treelite Model object\n \\param num_row Number of rows in the input\n \\param config Configuration of GTIL predictor. Set this by calling \\ref TreeliteGTILParseConfig.\n \\param out_shape Array of dimensions\n \\param out_ndim Number of dimensions in out_shape\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGTILGetOutputShape(
        model: TreeliteModelHandle,
        num_row: u64,
        config: TreeliteGTILConfigHandle,
        out: *mut *const u64,
        out_ndim: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Predict with a 2D dense array\n \\param model Treelite Model object\n \\param input The 2D data array, laid out in row-major layout\n \\param input_type Data type of the data matrix\n \\param num_row Number of rows in the data matrix.\n \\param output Pointer to buffer to store the output. Call \\ref TreeliteGTILGetOutputShape to get\n               the amount of buffer you should allocate for this parameter.\n \\param config Configuration of GTIL predictor. Set this by calling \\ref TreeliteGTILParseConfig.\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGTILPredict(
        model: TreeliteModelHandle,
        input: *const ::std::os::raw::c_void,
        input_type: *const ::std::os::raw::c_char,
        num_row: u64,
        output: *mut ::std::os::raw::c_void,
        config: TreeliteGTILConfigHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Predict with sparse data with CSR (compressed sparse row) layout.\n\n In the CSR layout, data[row_ptr[i]:row_ptr[i+1]] store the nonzero entries of row i, and\n col_ind[row_ptr[i]:row_ptr[i+1]] stores the corresponding column indices.\n\n \\param model Treelite Model object\n \\param data Nonzero elements in the data matrix\n \\param input_type Data type of the data matrix\n \\param col_ind Feature indices. col_ind[i] indicates the feature index associated with data[i].\n \\param row_ptr Pointer to row headers. Length is [num_row] + 1.\n \\param num_row Number of rows in the data matrix.\n \\param output Pointer to buffer to store the output. Call \\ref GetOutputShape to get\n               the amount of buffer you should allocate for this parameter.\n \\param config Configuration of GTIL predictor. Set this by calling \\ref TreeliteGTILParseConfig.\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGTILPredictSparse(
        model: TreeliteModelHandle,
        data: *const ::std::os::raw::c_void,
        input_type: *const ::std::os::raw::c_char,
        col_ind: *const u64,
        row_ptr: *const u64,
        num_row: u64,
        output: *mut ::std::os::raw::c_void,
        config: TreeliteGTILConfigHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup accessor C API: Getters and setters for tree fields\n The getter and setter methods are useful for modifying a tree model in-place. This interface\n should be used by an expert user, as the interface performs no validation for the setter.\n \\{\n/\n/*!\n \\brief Get a field in the header.\n\n This function returns the requested field using the Python buffer protocol (PEP 3118).\n \\param model Treelite Model object\n \\param name Name of the field\n \\param out_frame Buffer frame representing the requested field\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGetHeaderField(
        model: TreeliteModelHandle,
        name: *const ::std::os::raw::c_char,
        out_frame: *mut TreelitePyBufferFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get a field in a tree.\n\n This function returns the requested field using the Python buffer protocol (PEP 3118).\n \\param model Treelite Model object\n \\param tree_id ID of the tree\n \\param name Name of the field\n \\param out_frame Buffer frame representing the requested field\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteGetTreeField(
        model: TreeliteModelHandle,
        tree_id: u64,
        name: *const ::std::os::raw::c_char,
        out_frame: *mut TreelitePyBufferFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set a field in the header.\n\n This function accepts the field's new value using the Python buffer protocol (PEP 3118).\n \\param model Treelite Model object\n \\param name Name of the field\n \\param frame Buffer frame representing the new value for the field\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteSetHeaderField(
        model: TreeliteModelHandle,
        name: *const ::std::os::raw::c_char,
        frame: TreelitePyBufferFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set a field in a tree.\n\n This function accepts the field's new value using the Python buffer protocol (PEP 3118).\n \\param model Treelite Model object\n \\param tree_id ID of the tree\n \\param name Name of the field\n \\param frame Buffer frame representing the new value for the field\n \\return 0 for success; -1 for failure"]
    pub fn TreeliteSetTreeField(
        model: TreeliteModelHandle,
        tree_id: u64,
        name: *const ::std::os::raw::c_char,
        frame: TreelitePyBufferFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Display last error; can be called by multiple threads\n Note. Each thread will get the last error occured in its own context.\n \\return Error string"]
    pub fn TreeliteGetLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Register callback function for LOG(INFO) messages -- helpful messages\n        that are not errors.\n Note: This function can be called by multiple threads. The callback function\n       will run on the thread that registered it\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteRegisterLogCallback(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Register callback function for LOG(WARNING) messages\n Note: This function can be called by multiple threads. The callback function\n       will run on the thread that registered it\n \\return 0 for success, -1 for failure"]
    pub fn TreeliteRegisterWarningCallback(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut TREELITE_VERSION: *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
